# name: test/sql/gigapi.test
# description: Test GigAPI extension with parser hijacking
# group: [sql]

# Require statement will ensure this test is run with this extension loaded
require gigapi

# Queries to tables not indexed in GigAPI (i.e., not in Redis) should fail normally.
# This proves the extension is correctly passing through queries it shouldn't handle.
statement error
SELECT * FROM this_table_does_not_exist;
----
Catalog Error: Table with name this_table_does_not_exist does not exist!

# Test the dry run function to see the query rewriting
query T
SELECT gigapi_dry_run('SELECT * FROM my_test_table');
----
SELECT * FROM read_parquet(['dummy/file1.parquet', 'dummy/file2.parquet'])

# Test with a where clause that is preserved
query T
SELECT gigapi_dry_run('SELECT value FROM my_other_table WHERE value > 100');
----
SELECT "value" FROM read_parquet(['dummy/file1.parquet', 'dummy/file2.parquet']) WHERE ("value" > 100)

# Test with a time filter that is also preserved
query T
SELECT gigapi_dry_run('SELECT * FROM another_table WHERE time > ''2024-01-01''');
----
SELECT * FROM read_parquet(['dummy/file1.parquet', 'dummy/file2.parquet']) WHERE ("time" > '2024-01-01')

# Test the end-to-end planner hijacking.
# This requires a running redis instance, but we can test the case where the index is missing.
# First, create the secret. We assume a default Redis is running on localhost.
statement ok
CREATE SECRET gigapi (TYPE redis, HOST 'localhost', PORT '6379', PASSWORD '');

# Use our test helper to create an empty index for our table in Redis
query I
SELECT giga_test_create_empty_index('my_indexed_table_with_no_files');
----
true

# Now, query a table that should be hijacked.
# Since the key now EXISTS but is EMPTY, we expect the specific error message.
statement error
SELECT * FROM my_indexed_table_with_no_files;
----
No files found in Redis for table 'my_indexed_table_with_no_files' in the given time range.
